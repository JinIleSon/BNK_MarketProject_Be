<?xml version="1.0" encoding="UTF-8" ?>
        <!DOCTYPE mapper
                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="kr.co.bnk_marketproject_be.mapper.ProductsMapper">

<!-- 전체 상품 개수 -->
<select id="selectTotalProductCount" resultType="int">
    SELECT COUNT(*) FROM products
</select>

<select id="selectProductListPaged"
        resultType="kr.co.bnk_marketproject_be.dto.ProductsDTO">

    SELECT
    p.id,
    p.product_name                       AS product_name,
    p.description,
    p.sub_description                    AS sub_description,
    p.price,
    p.discount,
    p.delichar,
    -- 메인 이미지
    pi.url                                AS url,

    -- 파생 지표
    NVL(sales.sales_cnt, 0)               AS salesCount,   -- 판매량
    ROUND(NVL(rv.avg_rating, 0), 2)       AS ratingAvg,    -- 평균 별점
    NVL(rv.review_cnt, 0)                 AS ratingCnt     -- 리뷰 수

    FROM products p

    /* 메인 이미지 조인 */
    LEFT JOIN product_images pi
    ON pi.products_id = p.id
    AND pi.is_main = 'Y'

    /* 판매량: 주문 아이템에서 제품별 수량 합계 */
    LEFT JOIN (
    SELECT oi.products_id,
    SUM(oi.quantity) AS sales_cnt
    FROM order_items oi
    GROUP BY oi.products_id
    ) sales
    ON sales.products_id = p.id

    /* 리뷰: product_boards에서 type='review'만 */
    LEFT JOIN (
    SELECT pb.products_id,
    AVG(pb.rating) AS avg_rating,
    COUNT(*)       AS review_cnt
    FROM product_boards pb
    WHERE pb.type = 'review'
    GROUP BY pb.products_id
    ) rv
    ON rv.products_id = p.id

    <!-- 정렬: 화이트리스트 -->
    <choose>
        <!-- 낮은가격순/높은가격순 : (원가-할인액) = 최종가 기준 -->
        <when test="sort == 'priceAsc'">
            ORDER BY (p.price - NVL(p.discount,0)) ASC, p.created_at DESC
        </when>
        <when test="sort == 'priceDesc'">
            ORDER BY (p.price - NVL(p.discount,0)) DESC, p.created_at DESC
        </when>

        <!-- 평점높은순 / 후기많은순 -->
        <when test="sort == 'rating'">
            ORDER BY NVL(rv.avg_rating,0) DESC, NVL(rv.review_cnt,0) DESC, p.created_at DESC
        </when>
        <when test="sort == 'review'">
            ORDER BY NVL(rv.review_cnt,0) DESC, p.created_at DESC
        </when>

        <!-- 판매많은순 -->
        <when test="sort == 'sales'">
            ORDER BY NVL(sales.sales_cnt,0) DESC, p.created_at DESC
        </when>

        <!-- 최근등록순(기본) -->
        <otherwise>
            ORDER BY p.created_at DESC
        </otherwise>
    </choose>

    OFFSET #{page.offset} ROWS
    FETCH NEXT #{page.size} ROWS ONLY
</select>

<select id="selectProductSearch" resultType="kr.co.bnk_marketproject_be.dto.ProductsDTO">
    SELECT
    p.id, p.product_code as product_code, p.sellers_id as sellers_id, p.categories_id as categories_id,
    p.product_name as product_name, p.sub_description as sub_description, p.price, p.discount, p.hits,
    p.delichar,
    to_char(p.created_at,'YYYY-MM-DD HH24:MI:SS') as created_at,
    pi.url AS url,
    NVL(r.rating_avg,0)   AS ratingAvg,
    NVL(r.rating_cnt,0)   AS ratingCnt
    FROM products p
    LEFT JOIN product_images pi
    ON pi.products_id = p.id AND pi.is_main = 'Y'
    /* 평점/리뷰수 집계 */
    LEFT JOIN (
    SELECT products_id,
    AVG(rating) AS rating_avg,
    COUNT(*)    AS rating_cnt
    FROM product_boards
    WHERE type = 'review'
    GROUP BY products_id
    ) r ON r.products_id = p.id
    <where>
        <if test="req.keyword != null and req.keyword != ''">
            <choose>
                <when test="req.searchType == 'name'">
                    AND LOWER(p.product_name) LIKE LOWER('%' || #{req.keyword} || '%')
                </when>
                <when test="req.searchType == 'explain'">
                    AND LOWER(p.sub_description) LIKE LOWER('%' || #{req.keyword} || '%')
                </when>
                <otherwise>
                    AND (LOWER(p.product_name) LIKE LOWER('%' || #{req.keyword} || '%')
                    OR  LOWER(p.sub_description) LIKE LOWER('%' || #{req.keyword} || '%'))
                </otherwise>
            </choose>
        </if>

        <!-- 가격 범위 (할인가격 기준) -->
        <if test="req.minPrice != null">
            AND (p.price - NVL(p.discount,0)) &gt;= #{req.minPrice}
        </if>
        <if test="req.maxPrice != null">
            AND (p.price - NVL(p.discount,0)) &lt;= #{req.maxPrice}
        </if>
    </where>

    <!-- 정렬 -->
    <choose>
        <when test="req.sort == 'sales'">
            ORDER BY p.hits DESC
        </when>
        <when test="req.sort == 'priceAsc'">
            ORDER BY (p.price - NVL(p.discount,0)) ASC
        </when>
        <when test="req.sort == 'priceDesc'">
            ORDER BY (p.price - NVL(p.discount,0)) DESC
        </when>
        <when test="req.sort == 'rating'">
            ORDER BY r.rating_avg DESC NULLS LAST
        </when>
        <when test="req.sort == 'review'">
            ORDER BY r.rating_cnt DESC NULLS LAST
        </when>
        <otherwise>
            ORDER BY p.created_at DESC
        </otherwise>
    </choose>

    OFFSET #{req.offset} ROWS FETCH NEXT #{req.size} ROWS ONLY
</select>

<select id="selectProductSearchTotal" resultType="int">
    SELECT COUNT(*)
    FROM products p
    <where>
        <if test="req.keyword != null and req.keyword != ''">
            AND (LOWER(p.product_name)   LIKE LOWER('%' || #{req.keyword} || '%')
            OR  LOWER(p.sub_description)LIKE LOWER('%' || #{req.keyword} || '%'))
        </if>
        <if test="req.minPrice != null">
            AND (p.price - NVL(p.discount,0)) &gt;= #{req.minPrice}
        </if>
        <if test="req.maxPrice != null">
            AND (p.price - NVL(p.discount,0)) &lt;= #{req.maxPrice}
        </if>
    </where>
</select>

<select id="selectProductDetailBase"
        parameterType="int"
        resultType="kr.co.bnk_marketproject_be.dto.ProductViewsDTO">
    SELECT
    p.id                 AS id,
    p.product_code       AS product_code,
    p.product_name       AS product_name,
    p.description        AS description,
    p.sub_description    AS sub_description,
    TO_CHAR(p.created_at, 'YYYY-MM-DD HH24:MI:SS') AS created_at,
    p.price              AS price,
    p.discount           AS discount,
    p.delichar           AS delichar,
    p.sellers_id         AS sellers_id
    FROM products p
    WHERE p.id = #{id}
</select>

<select id="selectMainImage" parameterType="int" resultType="string">
    SELECT pi.url
    FROM product_images pi
    WHERE pi.products_id = #{id}
    AND pi.is_main = 'Y'               <!-- ← CHAR(1) 비교 -->
    FETCH FIRST 1 ROWS ONLY
</select>

<select id="selectProductDetailImages" parameterType="int" resultType="string">
    SELECT pi.url
    FROM product_images pi
    WHERE pi.products_id = #{id}
    AND pi.is_main = 'N'               <!-- ← CHAR(1) 비교 -->
    ORDER BY pi.created_at, pi.id        <!-- ← sort_order 삭제 -->
</select>

<select id="selectRatingAgg"
        parameterType="int"
        resultType="map">
    SELECT
    ROUND(AVG(pb.rating), 2) AS rating_avg,
    COUNT(1)                 AS rating_cnt
    FROM product_boards pb
    WHERE pb.type = 'REVIEW'
    AND pb.products_id = #{id}
</select>

<!-- 옵션 목록 (언더바 유지) -->
<select id="selectProductOptions"
        parameterType="int"
        resultType="kr.co.bnk_marketproject_be.dto.ProductOptionsDTO">
    SELECT
    po.option_name AS optionName,
    0              AS stock          -- STOCK 컬럼이 없으니 기본값(필요없으면 DTO에서도 제거)
    FROM product_options po
    JOIN products p
    ON p.product_code = po.product_code
    WHERE p.id = #{id}
    ORDER BY po.option_name
</select>

<!-- 리뷰 목록 -->
<select id="selectProductReviews"
        parameterType="int"
        resultType="kr.co.bnk_marketproject_be.dto.ProductBoardsDTO">
    SELECT
    SUBSTR(u.user_id, 1, 2) || '***'     AS userName,   -- ← nickname 대신 user_id 마스킹
    pb.rating                             AS rating,
    pb.content                            AS content,
    TO_CHAR(pb.created_at,'YYYY-MM-DD')   AS createdAt
    FROM product_boards pb
    JOIN users u ON u.id = pb.users_id
    WHERE pb.type = 'REVIEW'
    AND pb.products_id = #{id}
    ORDER BY pb.created_at DESC
</select>
</mapper>
